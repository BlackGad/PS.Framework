<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>
<# 
    var configurationFilePath = this.Host.ResolvePath("Palette.xml");
	var configuration = XDocument.Load(configurationFilePath); 
	var colorElements = configuration.XPathSelectElements("//Colors/Color[@Name and @Name[not(.=\"\")]]");
    var colors = colorElements.Select(c => {
        var name = c.Attribute(XName.Get("Name")).Value;
        try
        {
            var result = new TemplateColor
            {
                PropertyName = name,
                DefaultValue = c.Attribute(XName.Get("Value"))?.Value,
                Transform = ColorTransform.Parse(c.Attribute(XName.Get("Transform"))?.Value)
            };
            result.FieldName = char.ToLower(result.PropertyName[0]) + result.PropertyName.Substring(1);
            return result;
        }
        catch (Exception e)
        {
            throw new Exception($"Color '{name}' definition is invalid", e);
        }
        
    }).ToList();
#>
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Windows.Media;
using PS.Extensions;
using PS.WPF.ValueConverters;

namespace PS.WPF.Theme
{
    public static class ThemeColors
    {
        static ThemeColors()
        {
<# 
	foreach (var color in colors) 
    { 
        if(string.IsNullOrEmpty(color.DefaultValue))
        {
            continue;
        }
#>
            <#=color.PropertyName#> = (Color)ColorConverter.ConvertFromString("<#=color.DefaultValue#>");
<# 
    } 
#>
<# 
	foreach (var color in colors) 
    { 
        if(color.Transform == null)
        {
            continue;
        }
#>
            <#=color.PropertyName#> = ColorConverters.Apply<#=color.Transform.Effect#>(<#=color.Transform.Source#>, <#=color.Transform.Coefficient#>);
<# 
    } 
#>
        }

<# 
	foreach (var color in colors) 
    { 
        var propertyName = color.PropertyName;
        var fieldName = color.FieldName;
#>
        private static Color _<#=fieldName#>;
        public static Color <#=propertyName#>
        {
            get { return _<#=fieldName#>; }
            set
            {
                _<#=fieldName#> = value;
                <#=propertyName#>75 = ColorConverters.ApplyOpacity(value, 0.75);
                <#=propertyName#>50 = ColorConverters.ApplyOpacity(value, 0.50);
                <#=propertyName#>25 = ColorConverters.ApplyOpacity(value, 0.25);
            }
        }

        public static Color <#=propertyName#>25 { get; private set; }
        public static Color <#=propertyName#>50 { get; private set; }
        public static Color <#=propertyName#>75 { get; private set; }

<# 
    } 
#>
	}

    public static class ThemeBrushes
    {
        private static readonly ConcurrentDictionary<int, Brush> Cache = new ConcurrentDictionary<int, Brush>();

        private static int Key([CallerMemberName] string propertyName = null)
        {
            return Thread.CurrentThread.ManagedThreadId.GetHash().MergeHash(propertyName.GetHash());
        }

<# 
	foreach (var color in colors) 
    { 
        var propertyName = color.PropertyName;
        var fieldName = color.FieldName;
#>
        public static Brush <#=propertyName#>
        {
            get { return Cache.GetOrAdd(Key(), id => new SolidColorBrush(ThemeColors.<#=propertyName#>)); }
        }

        public static Brush <#=propertyName#>25
        {
            get { return Cache.GetOrAdd(Key(), id => new SolidColorBrush(ThemeColors.<#=propertyName#>25)); }
        }

        public static Brush <#=propertyName#>50
        {
            get { return Cache.GetOrAdd(Key(), id => new SolidColorBrush(ThemeColors.<#=propertyName#>50)); }
        }

        public static Brush <#=propertyName#>75
        {
            get { return Cache.GetOrAdd(Key(), id => new SolidColorBrush(ThemeColors.<#=propertyName#>75)); }
        }
<# 
    } 
#>
    }

    public class ThemePreset
    {

    }
}

<#+
    class TemplateColor
    {
        public string PropertyName;
        public string FieldName;
        public string DefaultValue;
        public ColorTransform Transform;
    }
    class ColorTransform
    {
        public static ColorTransform Parse(string source)
        {
            if(string.IsNullOrEmpty(source))
            {
                return null;
            }

            var parts = source.Split(':');
            if(parts.Length != 3)
            {
                throw new ArgumentException("Transform format is invalid. <SourceProperty>:<Effect>:<Coefficient>");
            }
            return new ColorTransform
            {
                Source = parts[0],
                Effect = parts[1],
                Coefficient = parts[2],
            };
        }
       

        public string Source;
        public string Effect;
        public string Coefficient;
    }
#>